# LinkChain 调用链执行器设计文档

## 1. 项目概述

LinkChain 是一个轻量级的调用链执行器库，专门设计用于API网关过滤、数据处理管道的前置后置处理、以及服务接口的数据过滤等辅助处理场景。项目通过配置驱动的方式实现数据流处理，无需开发即可完成复杂的数据过滤和转换逻辑。

### 1.1 核心定位

- **辅助处理工具**: 专注于数据的辅助处理，不承担核心业务逻辑
- **API网关过滤**: 为API网关提供请求过滤、验证、转换等功能
- **数据管道增强**: 作为数据处理管道的前置或后置处理节点
- **服务接口外挂**: 为现有服务接口提供可插拔的数据处理能力
- **简化流程目的**: 通过标准化挂件简化复杂的数据处理流程

### 1.2 核心特性

- **配置驱动执行**: 所有处理逻辑通过JSON配置控制，无需编程开发
- **单向顺序处理**: 挂件按注册顺序单向执行，数据在挂件间流转
- **数据不变性保证**: 原始请求参数和元数据在整个链中严格不变
- **轻量级架构**: 专注于数据过滤转换，避免复杂的业务逻辑处理
- **即插即用**: 挂件支持热配置，通过配置文件即可调整处理逻辑
- **标准化输出**: 统一的JSON格式输入输出，便于系统集成

### 1.3 设计原则

- **配置优于编程**: 通过配置文件控制所有处理逻辑，避免代码开发
- **简单优于复杂**: 专注于数据过滤转换，不处理复杂业务逻辑
- **辅助优于核心**: 作为辅助处理工具，不替代核心业务流程
- **标准优于定制**: 提供标准化挂件，覆盖常见数据处理场景
- **安全优于性能**: 确保数据处理的安全性和一致性

## 2. 系统架构设计

### 2.1 文件目录结构

```
src/
├── lib.rs                    # 库入口文件，导出公共API
├── core/                     # 核心模块
│   ├── mod.rs               # 核心模块导出
│   ├── context.rs           # 请求响应上下文定义
│   ├── status.rs            # 执行状态枚举定义
│   └── utils.rs             # 核心工具函数
├── chainware/               # 挂件框架
│   ├── mod.rs               # 挂件框架导出
│   ├── core.rs              # 挂件核心接口定义
│   └── config.rs            # 挂件配置结构定义
├── chain/                   # 链执行器
│   ├── mod.rs               # 链模块导出
│   └── executor.rs          # 链执行逻辑实现
├── utils/                   # 工具模块
│   ├── mod.rs               # 工具模块导出
│   └── json_path.rs         # JSONPath解析器
├── builtin/                 # 内置挂件库
│   ├── mod.rs               # 内置挂件导出
│   ├── registry.rs          # 挂件注册管理
│   ├── condition.rs         # 条件判断挂件
│   ├── regexp_condition.rs  # 正则条件挂件
│   ├── ip_blacklist.rs      # IP黑名单挂件
│   ├── ip_whitelist.rs      # IP白名单挂件
│   ├── extract_json.rs      # JSON提取挂件
│   ├── json_extract.rs      # JSON字段提取挂件
│   ├── regexp_extract.rs    # 正则提取挂件
│   ├── extract_sql.rs       # SQL提取挂件
│   ├── extract_map.rs       # 映射提取挂件
│   ├── map_fields.rs        # 字段映射挂件
│   ├── merge.rs             # 数据合并挂件
│   └── logger.rs            # 日志记录挂件
├── types/                   # 类型定义模块
└── plugins/                 # 扩展插件模块
```

### 2.2 核心数据结构（基于实际代码）

#### 2.2.1 请求上下文 (RequestContext)
```rust
/// 请求上下文
/// 包含执行链所需的所有输入信息
#[derive(Debug, Clone)]
pub struct RequestContext {
    /// 执行ID，用于追踪
    pub execution_id: String,
    /// 输入数据（JSON格式）
    pub params: serde_json::Value,
    /// 元数据（包含所有额外信息）
    pub meta: HashMap<String, serde_json::Value>,
    /// 执行开始时间
    pub start_time: u64,
}
```

#### 2.2.2 响应上下文 (ResponseContext)
```rust
/// 响应上下文
/// 包含执行结果和状态信息
#[derive(Debug, Clone)]
pub struct ResponseContext {
    /// 执行状态
    pub status: ExecutionStatus,
    /// 输出数据（JSON格式）
    pub data: Option<serde_json::Value>,
    /// 响应元数据
    pub meta: HashMap<String, serde_json::Value>,
    /// 执行结束时间
    pub end_time: u64,
}
```

#### 2.2.3 执行状态 (ExecutionStatus)
```rust
/// 执行状态枚举
/// 核心状态为 Continue，执行器根据状态判断是否继续执行
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ExecutionStatus {
    /// 继续执行（核心状态）
    Continue,
    /// 执行完成
    Completed,
    /// 数据异常错误
    Error,
    /// 拒绝执行
    Reject,
}
```

#### 2.2.4 挂件配置 (ChainwareConfig)
```rust
/// 节点配置
/// 通用配置结构，支持任意参数
#[derive(Debug, Clone)]
pub struct ChainwareConfig {
    /// 配置参数（通用参数，支持任意类型）
    pub config: HashMap<String, serde_json::Value>,
}
```

#### 2.2.5 挂件接口 (Chainware)
```rust
/// 链挂件接口（挂件接口）
/// 所有挂件都需要实现这个接口
pub trait Chainware: Send + Sync {
    /// 获取挂件名称
    fn name(&self) -> &str;

    /// 处理方法（核心方法）
    /// 挂件保持简单，主要做过滤判断和简单数据处理
    /// 参数：请求上下文、响应上下文、外部数据及上一个挂件返回数据
    /// 参数：挂件配置信息
    /// 返回：挂件的返回数据
    fn process(
        &self,
        request: &RequestContext,
        response: &mut ResponseContext,
        data: Option<serde_json::Value>,
        config: Option<&ChainwareConfig>,
    ) -> Option<serde_json::Value>;
}
```

### 2.3 核心组件架构

#### 2.3.1 链执行器 (ChainExecutor)
**文件位置**: `src/chain/executor.rs`
**功能职责**: 管理挂件列表，按序执行挂件，处理数据流转和状态控制

#### 2.3.2 挂件包装器 (ChainwareWrapper)
**文件位置**: `src/chainware/core.rs`
**功能职责**: 包装挂件实现，提供配置支持和启用状态检查

#### 2.3.3 挂件注册器 (Registry)
**文件位置**: `src/builtin/registry.rs`
**功能职责**: 管理内置挂件的注册和实例化

#### 2.3.4 JSONPath处理器
**文件位置**: `src/utils/json_path.rs`
**功能职责**: 提供JSONPath数据访问，支持数据查询和模板处理

## 3. 链执行流程设计（基于实际代码）

### 3.1 链执行器真实处理流程
```rust
// 基于src/chain/executor.rs的实际实现
pub fn execute(&self, request: RequestContext) -> ResponseContext {
    let mut response = ResponseContext::new();
    // 初始化数据为请求数据
    let mut params: serde_json::Value = request.params.clone();

    // 按顺序执行所有节点
    for node in &self.nodes {
        // 执行节点，获取返回数据
        let node_result = node.execute(&request, &mut response, Some(params.clone()));

        // 更新数据为当前节点的返回数据
        params = node_result.unwrap_or_default();

        // 根据响应状态判断是否继续执行
        match response.status {
            ExecutionStatus::Continue => continue,
            ExecutionStatus::Error | ExecutionStatus::Reject => break,
            ExecutionStatus::Completed => break,
        }
    }

    // 如果所有节点都执行完成且状态仍为Continue，则设置为Completed
    if response.status == ExecutionStatus::Continue {
        response.set_status(ExecutionStatus::Completed);
    }

    response.set_end_time();
    response
}
```

**执行流程说明**:
1. **数据初始化**: 将请求参数作为初始数据
2. **顺序执行**: 按注册顺序遍历所有挂件节点  
3. **数据流转**: 每个挂件的输出成为下一个挂件的输入
4. **状态控制**: 根据挂件返回的状态决定是否继续
5. **自动完成**: 所有挂件执行完毕自动设置为Completed状态

### 3.2 挂件包装器执行流程
```rust
// 基于src/chainware/core.rs的ChainwareWrapper实现
pub fn execute(
    &self,
    request: &RequestContext,
    response: &mut ResponseContext,
    data: Option<serde_json::Value>,
) -> Option<serde_json::Value> {
    if self.is_enabled() {
        let result = self.node.process(request, response, data, self.config.as_ref());
        if response.status == ExecutionStatus::Continue {
            response.data = result.clone();
        }
        result
    } else {
        None
    }
}
```

**包装器职责**:
1. **启用检查**: 检查挂件是否启用，禁用的挂件直接跳过
2. **调用处理**: 调用实际挂件的process方法
3. **状态同步**: 仅在Continue状态时更新响应数据
4. **结果返回**: 返回挂件处理结果

### 3.3 真实数据流转机制

#### 数据在挂件间的实际流转
```
RequestContext.params (初始数据)
    ↓
Chainware1.process(data=params) → result1
    ↓  
Chainware2.process(data=result1) → result2
    ↓
ChainwareN.process(data=resultN-1) → resultN
    ↓
ResponseContext.data = resultN (最终输出)
```

#### 上下文数据访问 (JSONPath)
- **request.params**: 原始请求参数，挂件内可通过 `$params` 访问
- **request.meta**: 请求元数据，挂件内可通过 `$meta` 访问  
- **当前数据**: 挂件处理的当前数据，可通过 `$.` 或 `$input` 访问

### 3.4 挂件添加机制
```rust
// 基于executor.rs的add_chainware实现
pub fn add_chainware<F>(
    mut self,
    name: &str,
    callback: Option<F>,
    config: Option<ChainwareConfig>,
) -> Self {
    let chainware: Box<dyn Chainware> = if let Some(cb) = callback {
        // 优先使用自定义回调
        Box::new(Closureware::new(name.to_string(), cb))
    } else {
        // 尝试使用内置挂件
        let registry = get_global_registry();
        match registry.create_chainware(name) {
            Some(chainware) => chainware,
            None => panic!("未找到内置挂件: {}", name),
        }
    };
    
    let wrapper = ChainwareWrapper::new(chainware, config);
    self.nodes.push(wrapper);
    self
}
```

**添加机制说明**:
1. **优先级**: 自定义回调优先于内置挂件
2. **注册查找**: 从全局注册器查找内置挂件
3. **配置包装**: 将挂件和配置包装到ChainwareWrapper中
4. **顺序添加**: 按添加顺序构建执行链

## 4. 内置挂件库详细设计（基于实际功能）

### 4.1 条件验证类挂件 (2个)

#### 4.1.1 condition (条件判断挂件)
**文件位置**: `src/builtin/condition.rs`
**实际功能**: 基于条件表达式或JSONPath进行数据过滤
**支持的条件格式**:
- 基本比较: `$input.field == value`, `$input > 10`
- 字符串操作: `String.startsWith($input.field, "prefix")`
- 类型检查: `Chain.isString($input.field)`, `Chain.isNumber($input.field)`
- 长度检查: `$input.field.length > 5`, `$input.array.length == 0`
- 复杂表达式: 支持 `&&` 和 `||` 逻辑运算符

#### 4.1.2 regexp_condition (正则条件挂件) 
**文件位置**: `src/builtin/regexp_condition.rs`
**实际功能**: 基于正则表达式的文本匹配和验证

### 4.2 数据提取类挂件 (4个)

#### 4.2.1 extract_json (JSON提取挂件)
**文件位置**: `src/builtin/extract_json.rs`
**实际功能**: 从文本中按出现顺序智能提取JSON对象和数组
**核心特性**:
- 按字符顺序扫描，支持 `{` 对象和 `[` 数组
- 智能括号匹配，确保JSON结构完整
- 自动验证JSON格式有效性
- 优先返回第一个有效的JSON结构

#### 4.2.2 json_extract (JSON字段提取挂件)
**文件位置**: `src/builtin/json_extract.rs`
**实际功能**: 从JSON数据中提取指定字段

#### 4.2.3 regexp_extract (正则提取挂件)
**文件位置**: `src/builtin/regexp_extract.rs`
**实际功能**: 使用正则表达式从文本中提取数据

#### 4.2.4 extract_sql (SQL提取挂件)
**文件位置**: `src/builtin/extract_sql.rs`
**实际功能**: 从文本中提取SQL语句

### 4.3 数据处理类挂件 (3个)

#### 4.3.1 map_fields (字段映射挂件)
**文件位置**: `src/builtin/map_fields.rs`
**实际功能**: 将对象的字段进行重命名和转换
**业务模式**:
- **overwrite=true**: 在原对象基础上添加映射字段（容错性强）
- **overwrite=false**: 创建新对象只包含映射字段（严格模式）
**支持场景**:
- 对象字段映射：复制原对象，添加新字段
- 数组元素映射：循环处理数组中的每个对象元素
- JSONPath模板：支持复杂的路径表达式

#### 4.3.2 merge (数据合并挂件)
**文件位置**: `src/builtin/merge.rs`
**实际功能**: 合并多个数据源或对象

#### 4.3.3 extract_map (映射提取挂件)
**文件位置**: `src/builtin/extract_map.rs`
**实际功能**: 按映射规则提取和重组数据

### 4.4 网络安全类挂件 (2个)

#### 4.4.1 ip_blacklist (IP黑名单挂件)
**文件位置**: `src/builtin/ip_blacklist.rs`
**实际功能**: 基于IP地址的黑名单过滤
**核心特性**:
- 支持单个IP地址精确匹配
- 支持CIDR网段格式 (如 `192.168.1.0/24`)
- 自动IPv4和IPv6地址处理
- 从`request.meta.ip_address`获取客户端IP
- 匹配黑名单时返回`ExecutionStatus::Reject`

#### 4.4.2 ip_whitelist (IP白名单挂件)
**文件位置**: `src/builtin/ip_whitelist.rs`
**实际功能**: 基于IP地址的白名单过滤
**核心特性**: 与黑名单挂件类似，但逻辑相反

### 4.5 辅助工具挂件 (1个)

#### 4.5.1 logger (日志记录挂件)
**文件位置**: `src/builtin/logger.rs`
**实际功能**: 记录处理过程和调试信息

### 4.6 挂件注册管理

#### registry (挂件注册器)
**文件位置**: `src/builtin/registry.rs`
**实际功能**: 管理所有内置挂件的注册和实例化
**提供的挂件类型**:
- `condition` - 条件判断挂件
- `regexp_condition` - 正则条件挂件
- `ip_blacklist` - IP黑名单挂件
- `ip_whitelist` - IP白名单挂件
- `extract_json` - JSON提取挂件
- `json_extract` - JSON字段提取挂件
- `regexp_extract` - 正则提取挂件
- `extract_sql` - SQL提取挂件
- `extract_map` - 映射提取挂件
- `map_fields` - 字段映射挂件
- `merge` - 数据合并挂件
- `logger` - 日志记录挂件

## 5. 典型应用场景

### 5.1 API网关数据过滤
**应用场景**: 在API网关中作为请求预处理模块
**处理链示例**:
```
IP黑名单过滤 -> 条件验证 -> JSON提取 -> 字段映射 -> 日志记录
```
**配置驱动**: 通过配置文件控制过滤规则，无需修改代码

### 5.2 数据处理管道前置处理
**应用场景**: 在数据处理管道前对原始数据进行清洗和标准化
**处理链示例**:
```
JSON提取 -> 条件过滤 -> 字段映射 -> 数据合并
```
**简化目的**: 标准化数据格式，减少后续处理复杂度

### 5.3 服务接口数据增强
**应用场景**: 为现有服务接口提供外挂式数据处理能力
**处理链示例**:
```
原始数据 -> 字段提取 -> 条件判断 -> 数据映射 -> 增强结果
```
**辅助处理**: 不改变核心业务逻辑，通过配置增强数据处理能力

### 5.4 配置驱动的优势
- **无需开发**: 所有处理逻辑通过JSON配置控制
- **快速调整**: 修改配置即可改变处理行为
- **标准化**: 提供11个内置挂件覆盖常见场景
- **组合灵活**: 不同挂件可灵活组合满足复杂需求

## 6. 技术特性总结

### 6.1 架构特性
- **轻量级设计**: 专注于数据辅助处理，避免重量级框架复杂性
- **配置优于编程**: 通过JSON配置控制所有处理逻辑
- **单向数据流**: 数据在挂件间单向流转，逻辑清晰
- **状态驱动**: 通过ExecutionStatus控制流程，支持错误处理和提前终止

### 6.2 数据安全特性
- **原始数据不变**: request.params和request.meta在整个处理过程中保持不变
- **流转数据隔离**: 每个挂件处理独立的数据副本
- **错误隔离**: 单个挂件错误不影响整体架构稳定性

### 6.3 扩展特性
- **内置挂件丰富**: 提供11个常用挂件覆盖主要处理场景
- **自定义挂件**: 支持通过回调函数创建自定义处理逻辑
- **配置灵活**: 每个挂件支持独立配置和启用控制

LinkChain通过简洁的设计和配置驱动的理念，为API网关过滤、数据处理管道和服务接口增强等场景提供了高效的辅助处理解决方案。
